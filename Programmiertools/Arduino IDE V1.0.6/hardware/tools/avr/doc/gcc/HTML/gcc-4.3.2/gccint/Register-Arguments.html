<html lang="en">
<head>
<title>Register Arguments - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Stack-and-Calling.html#Stack-and-Calling" title="Stack and Calling">
<link rel="prev" href="Stack-Arguments.html#Stack-Arguments" title="Stack Arguments">
<link rel="next" href="Scalar-Return.html#Scalar-Return" title="Scalar Return">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
2007 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Register-Arguments"></a>Next:&nbsp;<a rel="next" accesskey="n" href="Scalar-Return.html#Scalar-Return">Scalar Return</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Stack-Arguments.html#Stack-Arguments">Stack Arguments</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Stack-and-Calling.html#Stack-and-Calling">Stack and Calling</a>
<hr><br>
</div>

<h4 class="subsection">15.10.7 Passing Arguments in Registers</h4>

<p><a name="index-arguments-in-registers-3669"></a><a name="index-registers-arguments-3670"></a>
This section describes the macros which let you control how various
types of arguments are passed in registers or how they are arranged in
the stack.

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG</b> (<var>cum, mode, type, named</var>)<var><a name="index-FUNCTION_005fARG-3671"></a></var><br>
<blockquote><p>A C expression that controls whether a function argument is passed
in a register, and which register.

      <p>The arguments are <var>cum</var>, which summarizes all the previous
arguments; <var>mode</var>, the machine mode of the argument; <var>type</var>,
the data type of the argument as a tree node or 0 if that is not known
(which happens for C support library functions); and <var>named</var>,
which is 1 for an ordinary argument and 0 for nameless arguments that
correspond to <span class="samp">...</span> in the called function's prototype. 
<var>type</var> can be an incomplete type if a syntax error has previously
occurred.

      <p>The value of the expression is usually either a <code>reg</code> RTX for the
hard register in which to pass the argument, or zero to pass the
argument on the stack.

      <p>For machines like the VAX and 68000, where normally all arguments are
pushed, zero suffices as a definition.

      <p>The value of the expression can also be a <code>parallel</code> RTX.  This is
used when an argument is passed in multiple locations.  The mode of the
<code>parallel</code> should be the mode of the entire argument.  The
<code>parallel</code> holds any number of <code>expr_list</code> pairs; each one
describes where part of the argument is passed.  In each
<code>expr_list</code> the first operand must be a <code>reg</code> RTX for the hard
register in which to pass this part of the argument, and the mode of the
register RTX indicates how large this part of the argument is.  The
second operand of the <code>expr_list</code> is a <code>const_int</code> which gives
the offset in bytes into the entire argument of where this part starts. 
As a special exception the first <code>expr_list</code> in the <code>parallel</code>
RTX may have a first operand of zero.  This indicates that the entire
argument is also stored on the stack.

      <p>The last time this macro is called, it is called with <code>MODE ==
VOIDmode</code>, and its result is passed to the <code>call</code> or <code>call_value</code>
pattern as operands 2 and 3 respectively.

      <p><a name="index-_0040file_007bstdarg_002eh_007d-and-register-arguments-3672"></a>The usual way to make the ISO library <span class="file">stdarg.h</span> work on a machine
where some arguments are usually passed in registers, is to cause
nameless arguments to be passed on the stack instead.  This is done
by making <code>FUNCTION_ARG</code> return 0 whenever <var>named</var> is 0.

      <p><a name="index-_0040code_007bTARGET_005fMUST_005fPASS_005fIN_005fSTACK_007d_002c-and-_0040code_007bFUNCTION_005fARG_007d-3673"></a><a name="index-_0040code_007bREG_005fPARM_005fSTACK_005fSPACE_007d_002c-and-_0040code_007bFUNCTION_005fARG_007d-3674"></a>You may use the hook <code>targetm.calls.must_pass_in_stack</code>
in the definition of this macro to determine if this argument is of a
type that must be passed in the stack.  If <code>REG_PARM_STACK_SPACE</code>
is not defined and <code>FUNCTION_ARG</code> returns nonzero for such an
argument, the compiler will abort.  If <code>REG_PARM_STACK_SPACE</code> is
defined, the argument will be computed in the stack and then loaded into
a register. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_MUST_PASS_IN_STACK</b> (<var>enum machine_mode mode, tree type</var>)<var><a name="index-TARGET_005fMUST_005fPASS_005fIN_005fSTACK-3675"></a></var><br>
<blockquote><p>This target hook should return <code>true</code> if we should not pass <var>type</var>
solely in registers.  The file <span class="file">expr.h</span> defines a
definition that is usually appropriate, refer to <span class="file">expr.h</span> for additional
documentation. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_INCOMING_ARG</b> (<var>cum, mode, type, named</var>)<var><a name="index-FUNCTION_005fINCOMING_005fARG-3676"></a></var><br>
<blockquote><p>Define this macro if the target machine has &ldquo;register windows&rdquo;, so
that the register in which a function sees an arguments is not
necessarily the same as the one in which the caller passed the
argument.

      <p>For such machines, <code>FUNCTION_ARG</code> computes the register in which
the caller passes the value, and <code>FUNCTION_INCOMING_ARG</code> should
be defined in a similar fashion to tell the function being called
where the arguments will arrive.

      <p>If <code>FUNCTION_INCOMING_ARG</code> is not defined, <code>FUNCTION_ARG</code>
serves both purposes. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: int <b>TARGET_ARG_PARTIAL_BYTES</b> (<var>CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, bool named</var>)<var><a name="index-TARGET_005fARG_005fPARTIAL_005fBYTES-3677"></a></var><br>
<blockquote><p>This target hook returns the number of bytes at the beginning of an
argument that must be put in registers.  The value must be zero for
arguments that are passed entirely in registers or that are entirely
pushed on the stack.

      <p>On some machines, certain arguments must be passed partially in
registers and partially in memory.  On these machines, typically the
first few words of arguments are passed in registers, and the rest
on the stack.  If a multi-word argument (a <code>double</code> or a
structure) crosses that boundary, its first few words must be passed
in registers and the rest must be pushed.  This macro tells the
compiler when this occurs, and how many bytes should go in registers.

      <p><code>FUNCTION_ARG</code> for these arguments should return the first
register to be used by the caller for this argument; likewise
<code>FUNCTION_INCOMING_ARG</code>, for the called function. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_PASS_BY_REFERENCE</b> (<var>CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, bool named</var>)<var><a name="index-TARGET_005fPASS_005fBY_005fREFERENCE-3678"></a></var><br>
<blockquote><p>This target hook should return <code>true</code> if an argument at the
position indicated by <var>cum</var> should be passed by reference.  This
predicate is queried after target independent reasons for being
passed by reference, such as <code>TREE_ADDRESSABLE (type)</code>.

      <p>If the hook returns true, a copy of that argument is made in memory and a
pointer to the argument is passed instead of the argument itself. 
The pointer is passed in whatever way is appropriate for passing a pointer
to that type. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_CALLEE_COPIES</b> (<var>CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, bool named</var>)<var><a name="index-TARGET_005fCALLEE_005fCOPIES-3679"></a></var><br>
<blockquote><p>The function argument described by the parameters to this hook is
known to be passed by reference.  The hook should return true if the
function argument should be copied by the callee instead of copied
by the caller.

      <p>For any argument for which the hook returns true, if it can be
determined that the argument is not modified, then a copy need
not be generated.

      <p>The default version of this hook always returns false. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CUMULATIVE_ARGS</b><var><a name="index-CUMULATIVE_005fARGS-3680"></a></var><br>
<blockquote><p>A C type for declaring a variable that is used as the first argument of
<code>FUNCTION_ARG</code> and other related values.  For some target machines,
the type <code>int</code> suffices and can hold the number of bytes of
argument so far.

      <p>There is no need to record in <code>CUMULATIVE_ARGS</code> anything about the
arguments that have been passed on the stack.  The compiler has other
variables to keep track of that.  For target machines on which all
arguments are passed on the stack, there is no need to store anything in
<code>CUMULATIVE_ARGS</code>; however, the data structure must exist and
should not be empty, so use <code>int</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INIT_CUMULATIVE_ARGS</b> (<var>cum, fntype, libname, fndecl, n_named_args</var>)<var><a name="index-INIT_005fCUMULATIVE_005fARGS-3681"></a></var><br>
<blockquote><p>A C statement (sans semicolon) for initializing the variable
<var>cum</var> for the state at the beginning of the argument list.  The
variable has type <code>CUMULATIVE_ARGS</code>.  The value of <var>fntype</var>
is the tree node for the data type of the function which will receive
the args, or 0 if the args are to a compiler support library function. 
For direct calls that are not libcalls, <var>fndecl</var> contain the
declaration node of the function.  <var>fndecl</var> is also set when
<code>INIT_CUMULATIVE_ARGS</code> is used to find arguments for the function
being compiled.  <var>n_named_args</var> is set to the number of named
arguments, including a structure return address if it is passed as a
parameter, when making a call.  When processing incoming arguments,
<var>n_named_args</var> is set to &minus;1.

      <p>When processing a call to a compiler support library function,
<var>libname</var> identifies which one.  It is a <code>symbol_ref</code> rtx which
contains the name of the function, as a string.  <var>libname</var> is 0 when
an ordinary C function call is being processed.  Thus, each time this
macro is called, either <var>libname</var> or <var>fntype</var> is nonzero, but
never both of them at once. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INIT_CUMULATIVE_LIBCALL_ARGS</b> (<var>cum, mode, libname</var>)<var><a name="index-INIT_005fCUMULATIVE_005fLIBCALL_005fARGS-3682"></a></var><br>
<blockquote><p>Like <code>INIT_CUMULATIVE_ARGS</code> but only used for outgoing libcalls,
it gets a <code>MODE</code> argument instead of <var>fntype</var>, that would be
<code>NULL</code>.  <var>indirect</var> would always be zero, too.  If this macro
is not defined, <code>INIT_CUMULATIVE_ARGS (cum, NULL_RTX, libname,
0)</code> is used instead. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>INIT_CUMULATIVE_INCOMING_ARGS</b> (<var>cum, fntype, libname</var>)<var><a name="index-INIT_005fCUMULATIVE_005fINCOMING_005fARGS-3683"></a></var><br>
<blockquote><p>Like <code>INIT_CUMULATIVE_ARGS</code> but overrides it for the purposes of
finding the arguments for the function being compiled.  If this macro is
undefined, <code>INIT_CUMULATIVE_ARGS</code> is used instead.

      <p>The value passed for <var>libname</var> is always 0, since library routines
with special calling conventions are never compiled with GCC.  The
argument <var>libname</var> exists for symmetry with
<code>INIT_CUMULATIVE_ARGS</code>. 
<!-- could use "this macro" in place of @code{INIT_CUMULATIVE_ARGS}, maybe. -->
<!-- mew 5feb93   i switched the order of the sentences.  -mew 10feb93 -->
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG_ADVANCE</b> (<var>cum, mode, type, named</var>)<var><a name="index-FUNCTION_005fARG_005fADVANCE-3684"></a></var><br>
<blockquote><p>A C statement (sans semicolon) to update the summarizer variable
<var>cum</var> to advance past an argument in the argument list.  The
values <var>mode</var>, <var>type</var> and <var>named</var> describe that argument. 
Once this is done, the variable <var>cum</var> is suitable for analyzing
the <em>following</em> argument with <code>FUNCTION_ARG</code>, etc.

      <p>This macro need not do anything if the argument in question was passed
on the stack.  The compiler knows how to track the amount of stack space
used for arguments without any special help. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG_PADDING</b> (<var>mode, type</var>)<var><a name="index-FUNCTION_005fARG_005fPADDING-3685"></a></var><br>
<blockquote><p>If defined, a C expression which determines whether, and in which direction,
to pad out an argument with extra space.  The value should be of type
<code>enum direction</code>: either <code>upward</code> to pad above the argument,
<code>downward</code> to pad below, or <code>none</code> to inhibit padding.

      <p>The <em>amount</em> of padding is always just enough to reach the next
multiple of <code>FUNCTION_ARG_BOUNDARY</code>; this macro does not control
it.

      <p>This macro has a default definition which is right for most systems. 
For little-endian machines, the default is to pad upward.  For
big-endian machines, the default is to pad downward for an argument of
constant size shorter than an <code>int</code>, and upward otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>PAD_VARARGS_DOWN</b><var><a name="index-PAD_005fVARARGS_005fDOWN-3686"></a></var><br>
<blockquote><p>If defined, a C expression which determines whether the default
implementation of va_arg will attempt to pad down before reading the
next argument, if that argument is smaller than its aligned space as
controlled by <code>PARM_BOUNDARY</code>.  If this macro is not defined, all such
arguments are padded down if <code>BYTES_BIG_ENDIAN</code> is true. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>BLOCK_REG_PADDING</b> (<var>mode, type, first</var>)<var><a name="index-BLOCK_005fREG_005fPADDING-3687"></a></var><br>
<blockquote><p>Specify padding for the last element of a block move between registers and
memory.  <var>first</var> is nonzero if this is the only element.  Defining this
macro allows better control of register function parameters on big-endian
machines, without using <code>PARALLEL</code> rtl.  In particular,
<code>MUST_PASS_IN_STACK</code> need not test padding and mode of types in
registers, as there is no longer a "wrong" part of a register;  For example,
a three byte aggregate may be passed in the high part of a register if so
required. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG_BOUNDARY</b> (<var>mode, type</var>)<var><a name="index-FUNCTION_005fARG_005fBOUNDARY-3688"></a></var><br>
<blockquote><p>If defined, a C expression that gives the alignment boundary, in bits,
of an argument with the specified mode and type.  If it is not defined,
<code>PARM_BOUNDARY</code> is used for all arguments. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>FUNCTION_ARG_REGNO_P</b> (<var>regno</var>)<var><a name="index-FUNCTION_005fARG_005fREGNO_005fP-3689"></a></var><br>
<blockquote><p>A C expression that is nonzero if <var>regno</var> is the number of a hard
register in which function arguments are sometimes passed.  This does
<em>not</em> include implicit arguments such as the static chain and
the structure-value address.  On many machines, no registers can be
used for this purpose since all function arguments are pushed on the
stack. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_SPLIT_COMPLEX_ARG</b> (<var>tree type</var>)<var><a name="index-TARGET_005fSPLIT_005fCOMPLEX_005fARG-3690"></a></var><br>
<blockquote><p>This hook should return true if parameter of type <var>type</var> are passed
as two scalar parameters.  By default, GCC will attempt to pack complex
arguments into the target's word size.  Some ABIs require complex arguments
to be split and treated as their individual components.  For example, on
AIX64, complex floats should be passed in a pair of floating point
registers, even though a complex float would fit in one 64-bit floating
point register.

      <p>The default value of this hook is <code>NULL</code>, which is treated as always
false. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_BUILD_BUILTIN_VA_LIST</b> (<var>void</var>)<var><a name="index-TARGET_005fBUILD_005fBUILTIN_005fVA_005fLIST-3691"></a></var><br>
<blockquote><p>This hook returns a type node for <code>va_list</code> for the target. 
The default version of the hook returns <code>void*</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: tree <b>TARGET_GIMPLIFY_VA_ARG_EXPR</b> (<var>tree valist, tree type, tree *pre_p, tree *post_p</var>)<var><a name="index-TARGET_005fGIMPLIFY_005fVA_005fARG_005fEXPR-3692"></a></var><br>
<blockquote><p>This hook performs target-specific gimplification of
<code>VA_ARG_EXPR</code>.  The first two parameters correspond to the
arguments to <code>va_arg</code>; the latter two are as in
<code>gimplify.c:gimplify_expr</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_VALID_POINTER_MODE</b> (<var>enum machine_mode mode</var>)<var><a name="index-TARGET_005fVALID_005fPOINTER_005fMODE-3693"></a></var><br>
<blockquote><p>Define this to return nonzero if the port can handle pointers
with machine mode <var>mode</var>.  The default version of this
hook returns true for both <code>ptr_mode</code> and <code>Pmode</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_SCALAR_MODE_SUPPORTED_P</b> (<var>enum machine_mode mode</var>)<var><a name="index-TARGET_005fSCALAR_005fMODE_005fSUPPORTED_005fP-3694"></a></var><br>
<blockquote><p>Define this to return nonzero if the port is prepared to handle
insns involving scalar mode <var>mode</var>.  For a scalar mode to be
considered supported, all the basic arithmetic and comparisons
must work.

      <p>The default version of this hook returns true for any mode
required to handle the basic C types (as defined by the port). 
Included here are the double-word arithmetic supported by the
code in <span class="file">optabs.c</span>. 
</p></blockquote></div>

<div class="defun">
&mdash; Target Hook: bool <b>TARGET_VECTOR_MODE_SUPPORTED_P</b> (<var>enum machine_mode mode</var>)<var><a name="index-TARGET_005fVECTOR_005fMODE_005fSUPPORTED_005fP-3695"></a></var><br>
<blockquote><p>Define this to return nonzero if the port is prepared to handle
insns involving vector mode <var>mode</var>.  At the very least, it
must have move patterns for this mode. 
</p></blockquote></div>

 </body></html>

