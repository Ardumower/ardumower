<html lang="en">
<head>
<title>Working with declarations - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Declarations.html#Declarations" title="Declarations">
<link rel="next" href="Internal-structure.html#Internal-structure" title="Internal structure">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
2007 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Working-with-declarations"></a>Next:&nbsp;<a rel="next" accesskey="n" href="Internal-structure.html#Internal-structure">Internal structure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Declarations.html#Declarations">Declarations</a>
<hr><br>
</div>

<h4 class="subsection">9.5.1 Working with declarations</h4>

<p>Some macros can be used with any kind of declaration.  These include:
     <dl>
<dt><code>DECL_NAME</code><a name="index-DECL_005fNAME-1826"></a><dd>This macro returns an <code>IDENTIFIER_NODE</code> giving the name of the
entity.

     <br><dt><code>TREE_TYPE</code><a name="index-TREE_005fTYPE-1827"></a><dd>This macro returns the type of the entity declared.

     <br><dt><code>TREE_FILENAME</code><a name="index-TREE_005fFILENAME-1828"></a><dd>This macro returns the name of the file in which the entity was
declared, as a <code>char*</code>.  For an entity declared implicitly by the
compiler (like <code>__builtin_memcpy</code>), this will be the string
<code>"&lt;internal&gt;"</code>.

     <br><dt><code>TREE_LINENO</code><a name="index-TREE_005fLINENO-1829"></a><dd>This macro returns the line number at which the entity was declared, as
an <code>int</code>.

     <br><dt><code>DECL_ARTIFICIAL</code><a name="index-DECL_005fARTIFICIAL-1830"></a><dd>This predicate holds if the declaration was implicitly generated by the
compiler.  For example, this predicate will hold of an implicitly
declared member function, or of the <code>TYPE_DECL</code> implicitly
generated for a class type.  Recall that in C++ code like:
     <pre class="smallexample">          struct S {};
     </pre>
     <p class="noindent">is roughly equivalent to C code like:
     <pre class="smallexample">          struct S {};
          typedef struct S S;
     </pre>
     <p>The implicitly generated <code>typedef</code> declaration is represented by a
<code>TYPE_DECL</code> for which <code>DECL_ARTIFICIAL</code> holds.

     <br><dt><code>DECL_NAMESPACE_SCOPE_P</code><a name="index-DECL_005fNAMESPACE_005fSCOPE_005fP-1831"></a><dd>This predicate holds if the entity was declared at a namespace scope.

     <br><dt><code>DECL_CLASS_SCOPE_P</code><a name="index-DECL_005fCLASS_005fSCOPE_005fP-1832"></a><dd>This predicate holds if the entity was declared at a class scope.

     <br><dt><code>DECL_FUNCTION_SCOPE_P</code><a name="index-DECL_005fFUNCTION_005fSCOPE_005fP-1833"></a><dd>This predicate holds if the entity was declared inside a function
body.

 </dl>

 <p>The various kinds of declarations include:
     <dl>
<dt><code>LABEL_DECL</code><dd>These nodes are used to represent labels in function bodies.  For more
information, see <a href="Functions.html#Functions">Functions</a>.  These nodes only appear in block
scopes.

     <br><dt><code>CONST_DECL</code><dd>These nodes are used to represent enumeration constants.  The value of
the constant is given by <code>DECL_INITIAL</code> which will be an
<code>INTEGER_CST</code> with the same type as the <code>TREE_TYPE</code> of the
<code>CONST_DECL</code>, i.e., an <code>ENUMERAL_TYPE</code>.

     <br><dt><code>RESULT_DECL</code><dd>These nodes represent the value returned by a function.  When a value is
assigned to a <code>RESULT_DECL</code>, that indicates that the value should
be returned, via bitwise copy, by the function.  You can use
<code>DECL_SIZE</code> and <code>DECL_ALIGN</code> on a <code>RESULT_DECL</code>, just as
with a <code>VAR_DECL</code>.

     <br><dt><code>TYPE_DECL</code><dd>These nodes represent <code>typedef</code> declarations.  The <code>TREE_TYPE</code>
is the type declared to have the name given by <code>DECL_NAME</code>.  In
some cases, there is no associated name.

     <br><dt><code>VAR_DECL</code><dd>These nodes represent variables with namespace or block scope, as well
as static data members.  The <code>DECL_SIZE</code> and <code>DECL_ALIGN</code> are
analogous to <code>TYPE_SIZE</code> and <code>TYPE_ALIGN</code>.  For a declaration,
you should always use the <code>DECL_SIZE</code> and <code>DECL_ALIGN</code> rather
than the <code>TYPE_SIZE</code> and <code>TYPE_ALIGN</code> given by the
<code>TREE_TYPE</code>, since special attributes may have been applied to the
variable to give it a particular size and alignment.  You may use the
predicates <code>DECL_THIS_STATIC</code> or <code>DECL_THIS_EXTERN</code> to test
whether the storage class specifiers <code>static</code> or <code>extern</code> were
used to declare a variable.

     <p>If this variable is initialized (but does not require a constructor),
the <code>DECL_INITIAL</code> will be an expression for the initializer.  The
initializer should be evaluated, and a bitwise copy into the variable
performed.  If the <code>DECL_INITIAL</code> is the <code>error_mark_node</code>,
there is an initializer, but it is given by an explicit statement later
in the code; no bitwise copy is required.

     <p>GCC provides an extension that allows either automatic variables, or
global variables, to be placed in particular registers.  This extension
is being used for a particular <code>VAR_DECL</code> if <code>DECL_REGISTER</code>
holds for the <code>VAR_DECL</code>, and if <code>DECL_ASSEMBLER_NAME</code> is not
equal to <code>DECL_NAME</code>.  In that case, <code>DECL_ASSEMBLER_NAME</code> is
the name of the register into which the variable will be placed.

     <br><dt><code>PARM_DECL</code><dd>Used to represent a parameter to a function.  Treat these nodes
similarly to <code>VAR_DECL</code> nodes.  These nodes only appear in the
<code>DECL_ARGUMENTS</code> for a <code>FUNCTION_DECL</code>.

     <p>The <code>DECL_ARG_TYPE</code> for a <code>PARM_DECL</code> is the type that will
actually be used when a value is passed to this function.  It may be a
wider type than the <code>TREE_TYPE</code> of the parameter; for example, the
ordinary type might be <code>short</code> while the <code>DECL_ARG_TYPE</code> is
<code>int</code>.

     <br><dt><code>FIELD_DECL</code><dd>These nodes represent non-static data members.  The <code>DECL_SIZE</code> and
<code>DECL_ALIGN</code> behave as for <code>VAR_DECL</code> nodes. 
The position of the field within the parent record is specified by a
combination of three attributes.  <code>DECL_FIELD_OFFSET</code> is the position,
counting in bytes, of the <code>DECL_OFFSET_ALIGN</code>-bit sized word containing
the bit of the field closest to the beginning of the structure. 
<code>DECL_FIELD_BIT_OFFSET</code> is the bit offset of the first bit of the field
within this word; this may be nonzero even for fields that are not bit-fields,
since <code>DECL_OFFSET_ALIGN</code> may be greater than the natural alignment
of the field's type.

     <p>If <code>DECL_C_BIT_FIELD</code> holds, this field is a bit-field.  In a bit-field,
<code>DECL_BIT_FIELD_TYPE</code> also contains the type that was originally
specified for it, while DECL_TYPE may be a modified type with lesser precision,
according to the size of the bit field.

     <br><dt><code>NAMESPACE_DECL</code><dd>See <a href="Namespaces.html#Namespaces">Namespaces</a>.

     <br><dt><code>TEMPLATE_DECL</code><dd>
These nodes are used to represent class, function, and variable (static
data member) templates.  The <code>DECL_TEMPLATE_SPECIALIZATIONS</code> are a
<code>TREE_LIST</code>.  The <code>TREE_VALUE</code> of each node in the list is a
<code>TEMPLATE_DECL</code>s or <code>FUNCTION_DECL</code>s representing
specializations (including instantiations) of this template.  Back ends
can safely ignore <code>TEMPLATE_DECL</code>s, but should examine
<code>FUNCTION_DECL</code> nodes on the specializations list just as they
would ordinary <code>FUNCTION_DECL</code> nodes.

     <p>For a class template, the <code>DECL_TEMPLATE_INSTANTIATIONS</code> list
contains the instantiations.  The <code>TREE_VALUE</code> of each node is an
instantiation of the class.  The <code>DECL_TEMPLATE_SPECIALIZATIONS</code>
contains partial specializations of the class.

     <br><dt><code>USING_DECL</code><dd>
Back ends can safely ignore these nodes.

 </dl>

 </body></html>

