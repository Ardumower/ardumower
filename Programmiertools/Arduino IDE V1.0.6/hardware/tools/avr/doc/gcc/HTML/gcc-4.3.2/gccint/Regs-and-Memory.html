<html lang="en">
<head>
<title>Regs and Memory - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="RTL.html#RTL" title="RTL">
<link rel="prev" href="Constants.html#Constants" title="Constants">
<link rel="next" href="Arithmetic.html#Arithmetic" title="Arithmetic">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
2007 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Regs-and-Memory"></a>Next:&nbsp;<a rel="next" accesskey="n" href="Arithmetic.html#Arithmetic">Arithmetic</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Constants.html#Constants">Constants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="RTL.html#RTL">RTL</a>
<hr><br>
</div>

<h3 class="section">12.8 Registers and Memory</h3>

<p><a name="index-RTL-register-expressions-2418"></a><a name="index-RTL-memory-expressions-2419"></a>
Here are the RTL expression types for describing access to machine
registers and to main memory.

     
<a name="index-reg-2420"></a>
<a name="index-hard-registers-2421"></a>
<a name="index-pseudo-registers-2422"></a>
<dl><dt><code>(reg:</code><var>m</var> <var>n</var><code>)</code><dd>For small values of the integer <var>n</var> (those that are less than
<code>FIRST_PSEUDO_REGISTER</code>), this stands for a reference to machine
register number <var>n</var>: a <dfn>hard register</dfn>.  For larger values of
<var>n</var>, it stands for a temporary value or <dfn>pseudo register</dfn>. 
The compiler's strategy is to generate code assuming an unlimited
number of such pseudo registers, and later convert them into hard
registers or into memory references.

     <p><var>m</var> is the machine mode of the reference.  It is necessary because
machines can generally refer to each register in more than one mode. 
For example, a register may contain a full word but there may be
instructions to refer to it as a half word or as a single byte, as
well as instructions to refer to it as a floating point number of
various precisions.

     <p>Even for a register that the machine can access in only one mode,
the mode must always be specified.

     <p>The symbol <code>FIRST_PSEUDO_REGISTER</code> is defined by the machine
description, since the number of hard registers on the machine is an
invariant characteristic of the machine.  Note, however, that not
all of the machine registers must be general registers.  All the
machine registers that can be used for storage of data are given
hard register numbers, even those that can be used only in certain
instructions or can hold only certain types of data.

     <p>A hard register may be accessed in various modes throughout one
function, but each pseudo register is given a natural mode
and is accessed only in that mode.  When it is necessary to describe
an access to a pseudo register using a nonnatural mode, a <code>subreg</code>
expression is used.

     <p>A <code>reg</code> expression with a machine mode that specifies more than
one word of data may actually stand for several consecutive registers. 
If in addition the register number specifies a hardware register, then
it actually represents several consecutive hardware registers starting
with the specified one.

     <p>Each pseudo register number used in a function's RTL code is
represented by a unique <code>reg</code> expression.

     <p><a name="index-FIRST_005fVIRTUAL_005fREGISTER-2423"></a><a name="index-LAST_005fVIRTUAL_005fREGISTER-2424"></a>Some pseudo register numbers, those within the range of
<code>FIRST_VIRTUAL_REGISTER</code> to <code>LAST_VIRTUAL_REGISTER</code> only
appear during the RTL generation phase and are eliminated before the
optimization phases.  These represent locations in the stack frame that
cannot be determined until RTL generation for the function has been
completed.  The following virtual register numbers are defined:

          
<a name="index-VIRTUAL_005fINCOMING_005fARGS_005fREGNUM-2425"></a>
<dl><dt><code>VIRTUAL_INCOMING_ARGS_REGNUM</code><dd>This points to the first word of the incoming arguments passed on the
stack.  Normally these arguments are placed there by the caller, but the
callee may have pushed some arguments that were previously passed in
registers.

          <p><a name="index-_0040code_007bFIRST_005fPARM_005fOFFSET_007d-and-virtual-registers-2426"></a><a name="index-_0040code_007bARG_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2427"></a>When RTL generation is complete, this virtual register is replaced
by the sum of the register given by <code>ARG_POINTER_REGNUM</code> and the
value of <code>FIRST_PARM_OFFSET</code>.

          <p><a name="index-VIRTUAL_005fSTACK_005fVARS_005fREGNUM-2428"></a><a name="index-_0040code_007bFRAME_005fGROWS_005fDOWNWARD_007d-and-virtual-registers-2429"></a><br><dt><code>VIRTUAL_STACK_VARS_REGNUM</code><dd>If <code>FRAME_GROWS_DOWNWARD</code> is defined to a nonzero value, this points
to immediately above the first variable on the stack.  Otherwise, it points
to the first variable on the stack.

          <p><a name="index-_0040code_007bSTARTING_005fFRAME_005fOFFSET_007d-and-virtual-registers-2430"></a><a name="index-_0040code_007bFRAME_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2431"></a><code>VIRTUAL_STACK_VARS_REGNUM</code> is replaced with the sum of the
register given by <code>FRAME_POINTER_REGNUM</code> and the value
<code>STARTING_FRAME_OFFSET</code>.

          <p><a name="index-VIRTUAL_005fSTACK_005fDYNAMIC_005fREGNUM-2432"></a><br><dt><code>VIRTUAL_STACK_DYNAMIC_REGNUM</code><dd>This points to the location of dynamically allocated memory on the stack
immediately after the stack pointer has been adjusted by the amount of
memory desired.

          <p><a name="index-_0040code_007bSTACK_005fDYNAMIC_005fOFFSET_007d-and-virtual-registers-2433"></a><a name="index-_0040code_007bSTACK_005fPOINTER_005fREGNUM_007d-and-virtual-registers-2434"></a>This virtual register is replaced by the sum of the register given by
<code>STACK_POINTER_REGNUM</code> and the value <code>STACK_DYNAMIC_OFFSET</code>.

          <p><a name="index-VIRTUAL_005fOUTGOING_005fARGS_005fREGNUM-2435"></a><br><dt><code>VIRTUAL_OUTGOING_ARGS_REGNUM</code><dd>This points to the location in the stack at which outgoing arguments
should be written when the stack is pre-pushed (arguments pushed using
push insns should always use <code>STACK_POINTER_REGNUM</code>).

          <p><a name="index-_0040code_007bSTACK_005fPOINTER_005fOFFSET_007d-and-virtual-registers-2436"></a>This virtual register is replaced by the sum of the register given by
<code>STACK_POINTER_REGNUM</code> and the value <code>STACK_POINTER_OFFSET</code>. 
</dl>

     <p><a name="index-subreg-2437"></a><br><dt><code>(subreg:</code><var>m</var> <var>reg</var> <var>bytenum</var><code>)</code><dd><code>subreg</code> expressions are used to refer to a register in a machine
mode other than its natural one, or to refer to one register of
a multi-part <code>reg</code> that actually refers to several registers.

     <p>Each pseudo-register has a natural mode.  If it is necessary to
operate on it in a different mode&mdash;for example, to perform a fullword
move instruction on a pseudo-register that contains a single
byte&mdash;the pseudo-register must be enclosed in a <code>subreg</code>.  In
such a case, <var>bytenum</var> is zero.

     <p>Usually <var>m</var> is at least as narrow as the mode of <var>reg</var>, in which
case it is restricting consideration to only the bits of <var>reg</var> that
are in <var>m</var>.

     <p>Sometimes <var>m</var> is wider than the mode of <var>reg</var>.  These
<code>subreg</code> expressions are often called <dfn>paradoxical</dfn>.  They are
used in cases where we want to refer to an object in a wider mode but do
not care what value the additional bits have.  The reload pass ensures
that paradoxical references are only made to hard registers.

     <p>The other use of <code>subreg</code> is to extract the individual registers of
a multi-register value.  Machine modes such as <code>DImode</code> and
<code>TImode</code> can indicate values longer than a word, values which
usually require two or more consecutive registers.  To access one of the
registers, use a <code>subreg</code> with mode <code>SImode</code> and a
<var>bytenum</var> offset that says which register.

     <p>Storing in a non-paradoxical <code>subreg</code> has undefined results for
bits belonging to the same word as the <code>subreg</code>.  This laxity makes
it easier to generate efficient code for such instructions.  To
represent an instruction that preserves all the bits outside of those in
the <code>subreg</code>, use <code>strict_low_part</code> around the <code>subreg</code>.

     <p><a name="index-_0040code_007bWORDS_005fBIG_005fENDIAN_007d_002c-effect-on-_0040code_007bsubreg_007d-2438"></a>The compilation parameter <code>WORDS_BIG_ENDIAN</code>, if set to 1, says
that byte number zero is part of the most significant word; otherwise,
it is part of the least significant word.

     <p><a name="index-_0040code_007bBYTES_005fBIG_005fENDIAN_007d_002c-effect-on-_0040code_007bsubreg_007d-2439"></a>The compilation parameter <code>BYTES_BIG_ENDIAN</code>, if set to 1, says
that byte number zero is the most significant byte within a word;
otherwise, it is the least significant byte within a word.

     <p><a name="index-_0040code_007bFLOAT_005fWORDS_005fBIG_005fENDIAN_007d_002c-_0028lack-of_0029-effect-on-_0040code_007bsubreg_007d-2440"></a>On a few targets, <code>FLOAT_WORDS_BIG_ENDIAN</code> disagrees with
<code>WORDS_BIG_ENDIAN</code>. 
However, most parts of the compiler treat floating point values as if
they had the same endianness as integer values.  This works because
they handle them solely as a collection of integer values, with no
particular numerical value.  Only real.c and the runtime libraries
care about <code>FLOAT_WORDS_BIG_ENDIAN</code>.

     <p><a name="index-combiner-pass-2441"></a><a name="index-reload-pass-2442"></a><a name="index-_0040code_007bsubreg_007d_002c-special-reload-handling-2443"></a>Between the combiner pass and the reload pass, it is possible to have a
paradoxical <code>subreg</code> which contains a <code>mem</code> instead of a
<code>reg</code> as its first operand.  After the reload pass, it is also
possible to have a non-paradoxical <code>subreg</code> which contains a
<code>mem</code>; this usually occurs when the <code>mem</code> is a stack slot
which replaced a pseudo register.

     <p>Note that it is not valid to access a <code>DFmode</code> value in <code>SFmode</code>
using a <code>subreg</code>.  On some machines the most significant part of a
<code>DFmode</code> value does not have the same format as a single-precision
floating value.

     <p>It is also not valid to access a single word of a multi-word value in a
hard register when less registers can hold the value than would be
expected from its size.  For example, some 32-bit machines have
floating-point registers that can hold an entire <code>DFmode</code> value. 
If register 10 were such a register <code>(subreg:SI (reg:DF 10) 4)</code>
would be invalid because there is no way to convert that reference to
a single machine register.  The reload pass prevents <code>subreg</code>
expressions such as these from being formed.

     <p><a name="index-SUBREG_005fREG-2444"></a><a name="index-SUBREG_005fBYTE-2445"></a>The first operand of a <code>subreg</code> expression is customarily accessed
with the <code>SUBREG_REG</code> macro and the second operand is customarily
accessed with the <code>SUBREG_BYTE</code> macro.

     <p><a name="index-scratch-2446"></a><a name="index-scratch-operands-2447"></a><br><dt><code>(scratch:</code><var>m</var><code>)</code><dd>This represents a scratch register that will be required for the
execution of a single instruction and not used subsequently.  It is
converted into a <code>reg</code> by either the local register allocator or
the reload pass.

     <p><code>scratch</code> is usually present inside a <code>clobber</code> operation
(see <a href="Side-Effects.html#Side-Effects">Side Effects</a>).

     <p><a name="index-cc0-2448"></a><a name="index-condition-code-register-2449"></a><br><dt><code>(cc0)</code><dd>This refers to the machine's condition code register.  It has no
operands and may not have a machine mode.  There are two ways to use it:

          <ul>
<li>To stand for a complete set of condition code flags.  This is best on
most machines, where each comparison sets the entire series of flags.

          <p>With this technique, <code>(cc0)</code> may be validly used in only two
contexts: as the destination of an assignment (in test and compare
instructions) and in comparison operators comparing against zero
(<code>const_int</code> with value zero; that is to say, <code>const0_rtx</code>).

          <li>To stand for a single flag that is the result of a single condition. 
This is useful on machines that have only a single flag bit, and in
which comparison instructions must specify the condition to test.

          <p>With this technique, <code>(cc0)</code> may be validly used in only two
contexts: as the destination of an assignment (in test and compare
instructions) where the source is a comparison operator, and as the
first operand of <code>if_then_else</code> (in a conditional branch). 
</ul>

     <p><a name="index-cc0_005frtx-2450"></a>There is only one expression object of code <code>cc0</code>; it is the
value of the variable <code>cc0_rtx</code>.  Any attempt to create an
expression of code <code>cc0</code> will return <code>cc0_rtx</code>.

     <p>Instructions can set the condition code implicitly.  On many machines,
nearly all instructions set the condition code based on the value that
they compute or store.  It is not necessary to record these actions
explicitly in the RTL because the machine description includes a
prescription for recognizing the instructions that do so (by means of
the macro <code>NOTICE_UPDATE_CC</code>).  See <a href="Condition-Code.html#Condition-Code">Condition Code</a>.  Only
instructions whose sole purpose is to set the condition code, and
instructions that use the condition code, need mention <code>(cc0)</code>.

     <p>On some machines, the condition code register is given a register number
and a <code>reg</code> is used instead of <code>(cc0)</code>.  This is usually the
preferable approach if only a small subset of instructions modify the
condition code.  Other machines store condition codes in general
registers; in such cases a pseudo register should be used.

     <p>Some machines, such as the SPARC and RS/6000, have two sets of
arithmetic instructions, one that sets and one that does not set the
condition code.  This is best handled by normally generating the
instruction that does not set the condition code, and making a pattern
that both performs the arithmetic and sets the condition code register
(which would not be <code>(cc0)</code> in this case).  For examples, search
for <span class="samp">addcc</span> and <span class="samp">andcc</span> in <span class="file">sparc.md</span>.

     <p><a name="index-pc-2451"></a><br><dt><code>(pc)</code><dd><a name="index-program-counter-2452"></a>This represents the machine's program counter.  It has no operands and
may not have a machine mode.  <code>(pc)</code> may be validly used only in
certain specific contexts in jump instructions.

     <p><a name="index-pc_005frtx-2453"></a>There is only one expression object of code <code>pc</code>; it is the value
of the variable <code>pc_rtx</code>.  Any attempt to create an expression of
code <code>pc</code> will return <code>pc_rtx</code>.

     <p>All instructions that do not jump alter the program counter implicitly
by incrementing it, but there is no need to mention this in the RTL.

     <p><a name="index-mem-2454"></a><br><dt><code>(mem:</code><var>m</var> <var>addr</var> <var>alias</var><code>)</code><dd>This RTX represents a reference to main memory at an address
represented by the expression <var>addr</var>.  <var>m</var> specifies how large
a unit of memory is accessed.  <var>alias</var> specifies an alias set for the
reference.  In general two items are in different alias sets if they cannot
reference the same memory address.

     <p>The construct <code>(mem:BLK (scratch))</code> is considered to alias all
other memories.  Thus it may be used as a memory barrier in epilogue
stack deallocation patterns.

     <p><a name="index-addressof-2455"></a><br><dt><code>(addressof:</code><var>m</var> <var>reg</var><code>)</code><dd>This RTX represents a request for the address of register <var>reg</var>.  Its mode
is always <code>Pmode</code>.  If there are any <code>addressof</code>
expressions left in the function after CSE, <var>reg</var> is forced into the
stack and the <code>addressof</code> expression is replaced with a <code>plus</code>
expression for the address of its stack slot.

     <p><a name="index-concat-2456"></a><br><dt><code>(concat</code><var>m</var> <var>rtx</var> <var>rtx</var><code>)</code><dd>This RTX represents the concatenation of two other RTXs.  This is used
for complex values.  It should only appear in the RTL attached to
declarations and during RTL generation.  It should not appear in the
ordinary insn chain.

     <p><a name="index-concatn-2457"></a><br><dt><code>(concatn</code><var>m</var><code> [</code><var>rtx</var><code> ...])</code><dd>This RTX represents the concatenation of all the <var>rtx</var> to make a
single value.  Like <code>concat</code>, this should only appear in
declarations, and not in the insn chain. 
</dl>

 </body></html>

